
def readUserInput(String prompt, String defaultValue = "") {
    def console = System.console()
    if (console != null) {
        def input = console.readLine(prompt)
        return input?.trim() ?: defaultValue
    }

    println prompt
    def reader = new BufferedReader(new InputStreamReader(System.in))
    def input = reader.readLine()?.trim()
    return input ?: defaultValue
}

def checkHostDockerInternalAvailability() {
    try {
        def checkCommand = ["sh", "-c", "docker run --rm --add-host=host.docker.internal:host-gateway alpine sh -c 'ping -c 1 -W 1 host.docker.internal > /dev/null 2>&1 && echo \"available\" || echo \"not_available\"'"]
        def process = checkCommand.execute()
        def output = new StringBuilder()
        def error = new StringBuilder()
        process.consumeProcessOutput(output, error)
        def exitCode = process.waitFor()
        def outputText = output.toString().trim()

        if (exitCode == 0 && outputText.equals("available")) {
            logger.info("host.docker.internal is available")
            return true
        }
        return false
    } catch (Exception e) {
        logger.warn("Failed to check host.docker.internal: ${e.message}")
        return false
    }
}

def detectDockerBridgeIP(String defaultIp, def yellow, def green, def reset) {
    try {
        def command = ["sh", "-c", "docker run --rm alpine sh -c 'ip route show default | head -1 | cut -d\" \" -f3'"]
        def process = command.execute()
        def output = new StringBuilder()
        def error = new StringBuilder()
        process.consumeProcessOutput(output, error)
        def exitCode = process.waitFor()
        def outputText = output.toString().trim()

        if (exitCode == 0 && outputText && !outputText.isEmpty()) {
            logger.info("Successfully detected Docker bridge IP: '${outputText}'")
            return outputText
        }
    } catch (Exception e) {
        logger.error("Failed to detect Docker bridge IP: ${e.message}")
    }

    println "${yellow}âš ï¸ WARNING: Failed to automatically detect Docker bridge IP.${reset}"
    println "${yellow}Please run: docker run --rm alpine sh -c 'ip route show default | head -1 | cut -d\" \" -f3'${reset}"
    println ""

    return readUserInput("${yellow}ğŸ’¬ Enter Docker bridge IP or press Enter for default (${defaultIp}): ${reset}", defaultIp)
}

def getGatewayIpForDocker(String defaultIp, def yellow, def green, def reset) {
    if (checkHostDockerInternalAvailability()) {
        return "host.docker.internal"
    }
    return detectDockerBridgeIP(defaultIp, yellow, green, reset)
}

task 'mainui.variables.setup' {
    group = "configuration"
    description = "Detects and prints the suggested MainUI and Tomcat configuration variables."

    doLast {
        def yellow = "\u001B[33;1m"
        def red = "\u001B[31;1m"
        def green = "\u001B[32;1m"
        def blue = "\u001B[34;1m"
        def reset = "\u001B[0m"

        // === CONTEXT NAME ===
        def contextName = project.findProperty("context.name")
        if (!contextName) {
            throw new GradleException("${red}âŒ ERROR: Missing required property 'context.name'. Use -Pcontext.name=your_context${reset}")
        }

        println ""
        println "${blue}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${reset}"
        println "${blue}â•‘           MainUI Configuration Setup Wizard                    â•‘${reset}"
        println "${blue}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${reset}"
        println ""

        // === DETECT TOMCAT MODE ===
        def tomcatMode = null
        if (project.hasProperty("docker_com.etendoerp.tomcat") &&
                project.property("docker_com.etendoerp.tomcat").toString() == "true") {
            tomcatMode = "docker"
            println "${green}âœ“ Detected Tomcat Docker mode from gradle.properties${reset}"
        }

        while (!tomcatMode) {
            def sourcesPath = project.findProperty("sources.path")
            if (sourcesPath && sourcesPath.toString().toLowerCase().startsWith("/opt/etendoerp")) {
                println "${yellow}ğŸ’¡ Detected sources.path in /opt/EtendoERP, suggesting 'server' mode for Tomcat.${reset}"
            }

            println ""
            println "${yellow}ğŸ“¦ Tomcat Configuration:${reset}"
            println "${yellow}   â€¢ 'docker'  â†’ Tomcat runs in Docker container${reset}"
            println "${yellow}   â€¢ 'local'   â†’ Tomcat runs directly on host machine${reset}"
            println "${yellow}   â€¢ 'server'  â†’ Tomcat runs in remote server${reset}"
            println ""

            tomcatMode = readUserInput("${yellow}ğŸ’¬ Select Tomcat mode [local/docker/server] (default: local): ${reset}", "local")

            if (!["local", "docker", "server"].contains(tomcatMode)) {
                println "${red}âŒ Invalid mode. Must be 'docker', 'local', or 'server'.${reset}"
                tomcatMode = null
            }
        }

        // === DETECT MAINUI MODE ===
        def mainUIMode = null
        if (project.hasProperty("docker_com.etendoerp.mainui") &&
                project.property("docker_com.etendoerp.mainui").toString() == "true") {
            mainUIMode = "docker"
            println "${green}âœ“ Detected MainUI Docker mode from gradle.properties${reset}"
        }

        while (!mainUIMode) {
            println ""
            println "${yellow}ğŸ¨ MainUI Configuration:${reset}"
            println "${yellow}   â€¢ 'docker' â†’ MainUI runs in Docker container (recommended)${reset}"
            println "${yellow}   â€¢ 'local'  â†’ MainUI runs directly on host machine${reset}"
            println ""

            mainUIMode = readUserInput("${yellow}ğŸ’¬ Select MainUI mode [local/docker] (default: docker): ${reset}", "docker")

            if (!["docker", "local"].contains(mainUIMode)) {
                println "${red}âŒ Invalid mode. Must be 'docker' or 'local'.${reset}"
                mainUIMode = null
            }
        }

        // === VALIDATION ===
        if (mainUIMode == "docker" && tomcatMode == "local") {
            println ""
            println "${yellow}âš ï¸  WARNING: Mixed Docker Configuration Detected${reset}"
            println "${yellow}   MainUI (Docker) + Tomcat (Local) requires special network setup.${reset}"
            println ""
        }

        // === TOMCAT PORT ===
        def tomcatPort = project.findProperty("tomcatPort") ?: project.findProperty("TOMCAT_PORT")

        if (!tomcatPort && tomcatMode != "docker") {
            if (tomcatMode == "server") {
                println ""
                println "${yellow}ğŸ’¡ Tip: Check server port with: sudo cat /etc/apache2/ports.conf${reset}"
            }
            println ""
            tomcatPort = readUserInput("${yellow}ğŸ’¬ Enter Tomcat port (default: 8080): ${reset}", "8080")
        }

        if (!tomcatPort) {
            tomcatPort = "8080"
        }

        def mainUIPort = "3000"

        // === VARIABLE CONSTRUCTION ===
        def etendoClassicUrl
        def etendoClassicHost
        def nextPublicAppUrl

        if (mainUIMode == "docker" && tomcatMode == "docker") {
            println ""
            println "${blue}ğŸ“‹ Configuration: Both services in Docker${reset}"

            etendoClassicUrl = "http://tomcat:8080/${contextName}"
            etendoClassicHost = "http://localhost:${tomcatPort}/${contextName}"
            nextPublicAppUrl = "http://localhost:${mainUIPort}"

        } else if (mainUIMode == "docker" && tomcatMode != "docker") {
            println ""
            println "${blue}ğŸ“‹ Configuration: MainUI in Docker, Tomcat on host${reset}"

            def defaultIp = "172.17.0.1"
            def gatewayIp = getGatewayIpForDocker(defaultIp, yellow, green, reset)

            etendoClassicUrl = "http://${gatewayIp}:${tomcatPort}/${contextName}"
            etendoClassicHost = "http://localhost:${tomcatPort}/${contextName}"
            nextPublicAppUrl = "http://localhost:${mainUIPort}"

        } else {
            println ""
            println "${blue}ğŸ“‹ Configuration: Both services running locally${reset}"

            etendoClassicUrl = "http://localhost:${tomcatPort}/${contextName}"
            etendoClassicHost = "http://localhost:${tomcatPort}/${contextName}"
            nextPublicAppUrl = "http://localhost:${mainUIPort}"
        }

        // === OUTPUT ===
        def properties = [
                'docker_com.etendoerp.mainui'       : mainUIMode == "docker" ? 'true' : 'false',
                'etendo.classic.url'                : etendoClassicUrl,
                'etendo.classic.host'               : etendoClassicHost,
                'next.public.app.url'               : nextPublicAppUrl,
                'authentication.class'              : 'com.etendoerp.etendorx.auth.SWSAuthenticationManager',
                'ws.maxInactiveInterval'            : '3600'
        ]

        // Try to write as JSON for interactive setup (if the project has the closure)
        boolean wasWrittenAsJson = false
        if (project.hasProperty('writeResultsForInteractiveSetup')) {
            try {
                wasWrittenAsJson = project.writeResultsForInteractiveSetup(properties)
            } catch (Exception e) {
                project.logger.debug("Failed to call project.writeResultsForInteractiveSetup: ${e.message}")
                wasWrittenAsJson = false
            }
        } else {
            project.logger.lifecycle("Interactive setup writer not registered on project; proceeding with console output.")
        }

        // Fallback to human-readable output
        if (!wasWrittenAsJson) {
            println ""
            println "${green}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${reset}"
            println "${green}â•‘  âœ… Suggested gradle.properties values                         â•‘${reset}"
            println "${green}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${reset}"
            println ""

            properties.each { key, value ->
                println "${green}${key}${reset}=${value}"
            }

            println ""
            println "${blue}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${reset}"
            println "${yellow}ğŸ’¡ Configuration Summary:${reset}"
            println "${yellow}   â€¢ MainUI Mode: ${mainUIMode}${reset}"
            println "${yellow}   â€¢ Tomcat Mode: ${tomcatMode}${reset}"

            if (mainUIMode == "docker" && tomcatMode != "docker") {
                println ""
                println "${yellow}âš ï¸  Mixed configuration requires:${reset}"
                println "${green}   docker run ... --add-host=host.docker.internal:host-gateway${reset}"
            }

            println "${blue}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${reset}"
            println ""
        }
    }
}
